import { NomadJob } from '../types/nomad';

export interface HCLGeneratorOptions {
  includeComments?: boolean;
  indentSize?: number;
  sortKeys?: boolean;
}

/**
 * Generate Nomad HCL from job specification
 */
export function generateHCL(nomadJob: NomadJob, options: HCLGeneratorOptions = {}): string {
  const opts = {
    includeComments: options.includeComments ?? true,
    indentSize: options.indentSize ?? 2,
    sortKeys: options.sortKeys ?? false,
  };

  const generator = new HCLGenerator(opts);
  return generator.generate(nomadJob);
}

class HCLGenerator {
  private output: string[] = [];
  private indentLevel = 0;

  constructor(private options: Required<HCLGeneratorOptions>) {}

  generate(nomadJob: NomadJob): string {
    this.output = [];
    this.indentLevel = 0;

    if (this.options.includeComments) {
      this.addComment('Generated by compose2hcl');
      this.addComment('Docker Compose to Nomad HCL Converter');
      this.addLine();
    }

    // Generate job blocks
    for (const [jobName, jobSpec] of Object.entries(nomadJob.job)) {
      this.generateJob(jobName, jobSpec);
    }

    return this.output.join('\n');
  }

  private generateJob(jobName: string, jobSpec: any) {
    if (this.options.includeComments) {
      this.addComment(`Job: ${jobName}`);
    }
    
    this.addLine(`job "${jobName}" {`);
    this.indent();

    // Job-level properties
    this.generateJobProperties(jobSpec);

    // Groups
    if (jobSpec.group) {
      for (const [groupName, group] of Object.entries(jobSpec.group)) {
        this.addLine();
        this.generateGroup(groupName, group);
      }
    }

    this.dedent();
    this.addLine('}');
  }

  private generateJobProperties(jobSpec: any) {
    const jobProperties = [
      'id', 'name', 'type', 'priority', 'region', 'namespace', 'datacenters',
      'all_at_once', 'consul_token', 'vault_token'
    ];

    jobProperties.forEach(prop => {
      if (jobSpec[prop] !== undefined) {
        this.generateProperty(prop, jobSpec[prop]);
      }
    });

    // Complex properties
    if (jobSpec.constraint) {
      this.generateConstraints(jobSpec.constraint);
    }

    if (jobSpec.affinity) {
      this.generateAffinities(jobSpec.affinity);
    }

    if (jobSpec.spread) {
      this.generateSpreads(jobSpec.spread);
    }

    if (jobSpec.migrate) {
      this.generateMigrate(jobSpec.migrate);
    }

    if (jobSpec.reschedule) {
      this.generateReschedule(jobSpec.reschedule);
    }

    if (jobSpec.update) {
      this.generateUpdate(jobSpec.update);
    }

    if (jobSpec.periodic) {
      this.generatePeriodic(jobSpec.periodic);
    }

    if (jobSpec.vault) {
      this.generateVault(jobSpec.vault);
    }

    if (jobSpec.meta) {
      this.generateMeta(jobSpec.meta);
    }
  }

  private generateGroup(groupName: string, group: any) {
    if (this.options.includeComments) {
      this.addComment(`Group: ${groupName}`);
    }

    this.addLine(`group "${groupName}" {`);
    this.indent();

    // Group properties
    const groupProperties = ['count', 'shutdown_delay', 'stop_after_client_disconnect', 'max_client_disconnect'];
    
    groupProperties.forEach(prop => {
      if (group[prop] !== undefined) {
        this.generateProperty(prop, group[prop]);
      }
    });

    // Complex group properties
    if (group.constraint) {
      this.generateConstraints(group.constraint);
    }

    if (group.affinity) {
      this.generateAffinities(group.affinity);
    }

    if (group.spread) {
      this.generateSpreads(group.spread);
    }

    if (group.network) {
      this.addLine();
      this.generateNetwork(group.network);
    }

    if (group.volume) {
      this.addLine();
      this.generateVolumes(group.volume);
    }

    if (group.service) {
      this.addLine();
      group.service.forEach((service: any) => {
        this.generateService(service);
      });
    }

    if (group.restart) {
      this.addLine();
      this.generateRestart(group.restart);
    }

    if (group.migrate) {
      this.addLine();
      this.generateMigrate(group.migrate);
    }

    if (group.reschedule) {
      this.addLine();
      this.generateReschedule(group.reschedule);
    }

    if (group.scaling) {
      this.addLine();
      this.generateScaling(group.scaling);
    }

    if (group.consul) {
      this.addLine();
      this.generateConsul(group.consul);
    }

    if (group.meta) {
      this.addLine();
      this.generateMeta(group.meta);
    }

    // Tasks
    if (group.task) {
      for (const [taskName, task] of Object.entries(group.task)) {
        this.addLine();
        this.generateTask(taskName, task);
      }
    }

    this.dedent();
    this.addLine('}');
  }

  private generateTask(taskName: string, task: any) {
    if (this.options.includeComments) {
      this.addComment(`Task: ${taskName}`);
    }

    this.addLine(`task "${taskName}" {`);
    this.indent();

    // Task properties
    const taskProperties = ['driver', 'user', 'leader', 'kill_timeout', 'kill_signal', 'shutdown_delay'];
    
    taskProperties.forEach(prop => {
      if (task[prop] !== undefined) {
        this.generateProperty(prop, task[prop]);
      }
    });

    // Task configuration
    if (task.config) {
      this.addLine();
      this.generateConfig(task.config);
    }

    if (task.env) {
      this.addLine();
      this.generateEnv(task.env);
    }

    if (task.resources) {
      this.addLine();
      this.generateResources(task.resources);
    }

    if (task.constraint) {
      this.addLine();
      this.generateConstraints(task.constraint);
    }

    if (task.affinity) {
      this.addLine();
      this.generateAffinities(task.affinity);
    }

    if (task.service) {
      this.addLine();
      task.service.forEach((service: any) => {
        this.generateService(service);
      });
    }

    if (task.artifact) {
      this.addLine();
      task.artifact.forEach((artifact: any) => {
        this.generateArtifact(artifact);
      });
    }

    if (task.template) {
      this.addLine();
      task.template.forEach((template: any) => {
        this.generateTemplate(template);
      });
    }

    if (task.vault) {
      this.addLine();
      this.generateVault(task.vault);
    }

    if (task.logs) {
      this.addLine();
      this.generateLogs(task.logs);
    }

    if (task.restart) {
      this.addLine();
      this.generateRestart(task.restart);
    }

    if (task.lifecycle) {
      this.addLine();
      this.generateLifecycle(task.lifecycle);
    }

    if (task.volume_mount) {
      this.addLine();
      this.generateVolumeMounts(task.volume_mount);
    }

    if (task.csi_plugin) {
      this.addLine();
      this.generateCSIPlugin(task.csi_plugin);
    }

    if (task.scaling) {
      this.addLine();
      this.generateScaling(task.scaling);
    }

    if (task.meta) {
      this.addLine();
      this.generateMeta(task.meta);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateProperty(name: string, value: any) {
    if (Array.isArray(value)) {
      this.addLine(`${name} = [${value.map(v => this.formatValue(v)).join(', ')}]`);
    } else {
      this.addLine(`${name} = ${this.formatValue(value)}`);
    }
  }

  private generateConfig(config: any) {
    this.addLine('config {');
    this.indent();

    Object.entries(config).forEach(([key, value]) => {
      this.generateProperty(key, value);
    });

    this.dedent();
    this.addLine('}');
  }

  private generateEnv(env: Record<string, string>) {
    this.addLine('env {');
    this.indent();

    Object.entries(env).forEach(([key, value]) => {
      this.addLine(`${key} = ${this.formatValue(value)}`);
    });

    this.dedent();
    this.addLine('}');
  }

  private generateResources(resources: any) {
    this.addLine('resources {');
    this.indent();

    ['cpu', 'memory', 'memory_max', 'disk'].forEach(prop => {
      if (resources[prop] !== undefined) {
        this.addLine(`${prop} = ${resources[prop]}`);
      }
    });

    if (resources.device) {
      resources.device.forEach((device: any) => {
        this.generateDevice(device);
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateDevice(device: any) {
    this.addLine('device {');
    this.indent();

    ['name', 'count'].forEach(prop => {
      if (device[prop] !== undefined) {
        this.generateProperty(prop, device[prop]);
      }
    });

    if (device.constraint) {
      this.generateConstraints(device.constraint);
    }

    if (device.affinity) {
      this.generateAffinities(device.affinity);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateNetwork(network: any) {
    this.addLine('network {');
    this.indent();

    if (network.mode) {
      this.addLine(`mode = ${this.formatValue(network.mode)}`);
    }

    if (network.port) {
      Object.entries(network.port).forEach(([portName, portConfig]) => {
        this.generatePort(portName, portConfig);
      });
    }

    if (network.dns) {
      this.generateDNS(network.dns);
    }

    this.dedent();
    this.addLine('}');
  }

  private generatePort(portName: string, portConfig: any) {
    this.addLine(`port "${portName}" {`);
    this.indent();

    ['static', 'to', 'host_network'].forEach(prop => {
      if (portConfig[prop] !== undefined) {
        this.addLine(`${prop} = ${portConfig[prop]}`);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateDNS(dns: any) {
    this.addLine('dns {');
    this.indent();

    ['servers', 'searches', 'options'].forEach(prop => {
      if (dns[prop]) {
        this.generateProperty(prop, dns[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateVolumes(volumes: Record<string, any>) {
    Object.entries(volumes).forEach(([volumeName, volume]) => {
      this.generateVolume(volumeName, volume);
    });
  }

  private generateVolume(volumeName: string, volume: any) {
    this.addLine(`volume "${volumeName}" {`);
    this.indent();

    ['type', 'source', 'read_only', 'access_mode', 'attachment_mode', 'per_alloc'].forEach(prop => {
      if (volume[prop] !== undefined) {
        this.generateProperty(prop, volume[prop]);
      }
    });

    if (volume.mount_options) {
      this.generateMountOptions(volume.mount_options);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateMountOptions(mountOptions: any) {
    this.addLine('mount_options {');
    this.indent();

    ['fs_type', 'mount_flags'].forEach(prop => {
      if (mountOptions[prop] !== undefined) {
        this.generateProperty(prop, mountOptions[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateVolumeMounts(volumeMounts: Record<string, any>) {
    Object.entries(volumeMounts).forEach(([mountName, mount]) => {
      this.generateVolumeMount(mountName, mount);
    });
  }

  private generateVolumeMount(mountName: string, mount: any) {
    this.addLine(`volume_mount {`);
    this.indent();

    ['volume', 'destination', 'read_only', 'propagation_mode'].forEach(prop => {
      if (mount[prop] !== undefined) {
        this.generateProperty(prop, mount[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateService(service: any) {
    this.addLine('service {');
    this.indent();

    const serviceProps = [
      'name', 'port', 'tags', 'canary_tags', 'enable_tag_override', 'address_mode',
      'task', 'provider', 'on_update'
    ];

    serviceProps.forEach(prop => {
      if (service[prop] !== undefined) {
        this.generateProperty(prop, service[prop]);
      }
    });

    if (service.meta) {
      this.generateMeta(service.meta);
    }

    if (service.canary_meta) {
      this.addLine('canary_meta {');
      this.indent();
      Object.entries(service.canary_meta).forEach(([key, value]) => {
        this.addLine(`${key} = ${this.formatValue(value)}`);
      });
      this.dedent();
      this.addLine('}');
    }

    if (service.tagged_addresses) {
      Object.entries(service.tagged_addresses).forEach(([tag, address]) => {
        this.addLine(`tagged_addresses {`);
        this.indent();
        this.addLine(`${tag} = ${this.formatValue(address)}`);
        this.dedent();
        this.addLine('}');
      });
    }

    if (service.check) {
      service.check.forEach((check: any) => {
        this.generateCheck(check);
      });
    }

    if (service.check_restart) {
      this.generateCheckRestart(service.check_restart);
    }

    if (service.connect) {
      this.generateConnect(service.connect);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateCheck(check: any) {
    this.addLine('check {');
    this.indent();

    const checkProps = [
      'name', 'type', 'command', 'args', 'path', 'protocol', 'port', 'expose',
      'address_mode', 'interval', 'timeout', 'initial_status', 'tls_skip_verify',
      'method', 'body', 'success_before_passing', 'failures_before_critical',
      'failures_before_warning', 'task', 'on_update'
    ];

    checkProps.forEach(prop => {
      if (check[prop] !== undefined) {
        this.generateProperty(prop, check[prop]);
      }
    });

    if (check.header) {
      Object.entries(check.header).forEach(([key, values]) => {
        this.addLine(`header {`);
        this.indent();
        this.addLine(`${key} = [${(values as string[]).map(v => this.formatValue(v)).join(', ')}]`);
        this.dedent();
        this.addLine('}');
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateCheckRestart(checkRestart: any) {
    this.addLine('check_restart {');
    this.indent();

    ['limit', 'grace', 'ignore_warnings'].forEach(prop => {
      if (checkRestart[prop] !== undefined) {
        this.generateProperty(prop, checkRestart[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateConnect(connect: any) {
    this.addLine('connect {');
    this.indent();

    if (connect.native !== undefined) {
      this.addLine(`native = ${connect.native}`);
    }

    if (connect.gateway) {
      this.generateGateway(connect.gateway);
    }

    if (connect.sidecar_service) {
      this.generateSidecarService(connect.sidecar_service);
    }

    if (connect.sidecar_task) {
      this.generateSidecarTask(connect.sidecar_task);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateGateway(gateway: any) {
    this.addLine('gateway {');
    this.indent();

    if (gateway.proxy) {
      this.generateGatewayProxy(gateway.proxy);
    }

    if (gateway.ingress) {
      this.generateIngress(gateway.ingress);
    }

    if (gateway.terminating) {
      this.generateTerminating(gateway.terminating);
    }

    if (gateway.mesh) {
      this.addLine('mesh {}');
    }

    this.dedent();
    this.addLine('}');
  }

  private generateGatewayProxy(proxy: any) {
    this.addLine('proxy {');
    this.indent();

    ['connect_timeout', 'envoy_gateway_bind_tagged_addresses', 'envoy_gateway_no_default_bind'].forEach(prop => {
      if (proxy[prop] !== undefined) {
        this.generateProperty(prop, proxy[prop]);
      }
    });

    if (proxy.envoy_gateway_bind_addresses) {
      Object.entries(proxy.envoy_gateway_bind_addresses).forEach(([name, addr]) => {
        this.addLine(`envoy_gateway_bind_addresses {`);
        this.indent();
        this.addLine(`${name} {`);
        this.indent();
        Object.entries(addr as any).forEach(([key, value]) => {
          this.generateProperty(key, value);
        });
        this.dedent();
        this.addLine('}');
        this.dedent();
        this.addLine('}');
      });
    }

    if (proxy.config) {
      this.generateConfig(proxy.config);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateIngress(ingress: any) {
    this.addLine('ingress {');
    this.indent();

    if (ingress.tls) {
      this.generateIngressTLS(ingress.tls);
    }

    if (ingress.listener) {
      ingress.listener.forEach((listener: any) => {
        this.generateIngressListener(listener);
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateIngressTLS(tls: any) {
    this.addLine('tls {');
    this.indent();

    ['enabled', 'tls_min_version', 'tls_max_version', 'cipher_suites'].forEach(prop => {
      if (tls[prop] !== undefined) {
        this.generateProperty(prop, tls[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateIngressListener(listener: any) {
    this.addLine('listener {');
    this.indent();

    ['port', 'protocol'].forEach(prop => {
      if (listener[prop] !== undefined) {
        this.generateProperty(prop, listener[prop]);
      }
    });

    if (listener.service) {
      listener.service.forEach((service: any) => {
        this.addLine('service {');
        this.indent();
        
        ['name', 'hosts'].forEach(prop => {
          if (service[prop] !== undefined) {
            this.generateProperty(prop, service[prop]);
          }
        });

        this.dedent();
        this.addLine('}');
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateTerminating(terminating: any) {
    this.addLine('terminating {');
    this.indent();

    if (terminating.service) {
      terminating.service.forEach((service: any) => {
        this.addLine('service {');
        this.indent();
        
        ['name', 'ca_file', 'cert_file', 'key_file', 'sni'].forEach(prop => {
          if (service[prop] !== undefined) {
            this.generateProperty(prop, service[prop]);
          }
        });

        this.dedent();
        this.addLine('}');
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateSidecarService(sidecarService: any) {
    this.addLine('sidecar_service {');
    this.indent();

    ['tags', 'port'].forEach(prop => {
      if (sidecarService[prop] !== undefined) {
        this.generateProperty(prop, sidecarService[prop]);
      }
    });

    if (sidecarService.proxy) {
      this.generateSidecarProxy(sidecarService.proxy);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateSidecarProxy(proxy: any) {
    this.addLine('proxy {');
    this.indent();

    ['local_service_address', 'local_service_port'].forEach(prop => {
      if (proxy[prop] !== undefined) {
        this.generateProperty(prop, proxy[prop]);
      }
    });

    if (proxy.config) {
      this.generateConfig(proxy.config);
    }

    if (proxy.upstreams) {
      proxy.upstreams.forEach((upstream: any) => {
        this.generateUpstream(upstream);
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateUpstream(upstream: any) {
    this.addLine('upstreams {');
    this.indent();

    ['destination_name', 'destination_namespace', 'local_bind_port', 'local_bind_address'].forEach(prop => {
      if (upstream[prop] !== undefined) {
        this.generateProperty(prop, upstream[prop]);
      }
    });

    if (upstream.config) {
      this.generateConfig(upstream.config);
    }

    if (upstream.mesh_gateway) {
      this.addLine('mesh_gateway {');
      this.indent();
      if (upstream.mesh_gateway.mode) {
        this.generateProperty('mode', upstream.mesh_gateway.mode);
      }
      this.dedent();
      this.addLine('}');
    }

    this.dedent();
    this.addLine('}');
  }

  private generateSidecarTask(sidecarTask: any) {
    this.addLine('sidecar_task {');
    this.indent();

    const props = ['name', 'driver', 'user', 'kill_timeout', 'shutdown_delay'];
    
    props.forEach(prop => {
      if (sidecarTask[prop] !== undefined) {
        this.generateProperty(prop, sidecarTask[prop]);
      }
    });

    if (sidecarTask.config) {
      this.generateConfig(sidecarTask.config);
    }

    if (sidecarTask.env) {
      this.generateEnv(sidecarTask.env);
    }

    if (sidecarTask.resources) {
      this.generateResources(sidecarTask.resources);
    }

    if (sidecarTask.logs) {
      this.generateLogs(sidecarTask.logs);
    }

    if (sidecarTask.meta) {
      this.generateMeta(sidecarTask.meta);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateArtifact(artifact: any) {
    this.addLine('artifact {');
    this.indent();

    ['source', 'destination', 'mode'].forEach(prop => {
      if (artifact[prop] !== undefined) {
        this.generateProperty(prop, artifact[prop]);
      }
    });

    if (artifact.options) {
      this.addLine('options {');
      this.indent();
      Object.entries(artifact.options).forEach(([key, value]) => {
        this.addLine(`${key} = ${this.formatValue(value)}`);
      });
      this.dedent();
      this.addLine('}');
    }

    if (artifact.headers) {
      Object.entries(artifact.headers).forEach(([key, value]) => {
        this.addLine(`header {`);
        this.indent();
        this.addLine(`${key} = ${this.formatValue(value)}`);
        this.dedent();
        this.addLine('}');
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateTemplate(template: any) {
    this.addLine('template {');
    this.indent();

    const templateProps = [
      'source', 'destination', 'change_mode', 'change_signal', 'splay', 'perms',
      'left_delimiter', 'right_delimiter', 'env_var', 'vault_grace', 'error_on_missing_key',
      'uid', 'gid'
    ];

    templateProps.forEach(prop => {
      if (template[prop] !== undefined) {
        this.generateProperty(prop, template[prop]);
      }
    });

    if (template.embedded_tmpl) {
      this.addLine('data = <<EOH');
      this.addLine(template.embedded_tmpl);
      this.addLine('EOH');
    }

    this.dedent();
    this.addLine('}');
  }

  private generateVault(vault: any) {
    this.addLine('vault {');
    this.indent();

    ['policies', 'env', 'change_mode', 'change_signal'].forEach(prop => {
      if (vault[prop] !== undefined) {
        this.generateProperty(prop, vault[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateLogs(logs: any) {
    this.addLine('logs {');
    this.indent();

    ['max_files', 'max_file_size', 'disabled'].forEach(prop => {
      if (logs[prop] !== undefined) {
        this.generateProperty(prop, logs[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateRestart(restart: any) {
    this.addLine('restart {');
    this.indent();

    ['attempts', 'delay', 'interval', 'mode'].forEach(prop => {
      if (restart[prop] !== undefined) {
        this.generateProperty(prop, restart[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateMigrate(migrate: any) {
    this.addLine('migrate {');
    this.indent();

    ['max_parallel', 'health_check', 'min_healthy_time', 'healthy_deadline'].forEach(prop => {
      if (migrate[prop] !== undefined) {
        this.generateProperty(prop, migrate[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateReschedule(reschedule: any) {
    this.addLine('reschedule {');
    this.indent();

    ['attempts', 'interval', 'delay', 'delay_function', 'max_delay', 'unlimited'].forEach(prop => {
      if (reschedule[prop] !== undefined) {
        this.generateProperty(prop, reschedule[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateUpdate(update: any) {
    this.addLine('update {');
    this.indent();

    const updateProps = [
      'max_parallel', 'health_check', 'min_healthy_time', 'healthy_deadline',
      'progress_deadline', 'auto_revert', 'auto_promote', 'canary', 'stagger'
    ];

    updateProps.forEach(prop => {
      if (update[prop] !== undefined) {
        this.generateProperty(prop, update[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generatePeriodic(periodic: any) {
    this.addLine('periodic {');
    this.indent();

    ['cron', 'prohibit_overlap', 'time_zone'].forEach(prop => {
      if (periodic[prop] !== undefined) {
        this.generateProperty(prop, periodic[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateLifecycle(lifecycle: any) {
    this.addLine('lifecycle {');
    this.indent();

    ['hook', 'sidecar'].forEach(prop => {
      if (lifecycle[prop] !== undefined) {
        this.generateProperty(prop, lifecycle[prop]);
      }
    });

    this.dedent();
    this.addLine('}');
  }

  private generateScaling(scaling: any) {
    this.addLine('scaling {');
    this.indent();

    ['enabled', 'min', 'max'].forEach(prop => {
      if (scaling[prop] !== undefined) {
        this.generateProperty(prop, scaling[prop]);
      }
    });

    if (scaling.policy) {
      Object.entries(scaling.policy).forEach(([key, value]) => {
        this.addLine(`policy {`);
        this.indent();
        this.addLine(`${key} = ${this.formatValue(value)}`);
        this.dedent();
        this.addLine('}');
      });
    }

    this.dedent();
    this.addLine('}');
  }

  private generateConsul(consul: any) {
    this.addLine('consul {');
    this.indent();

    if (consul.namespace) {
      this.generateProperty('namespace', consul.namespace);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateCSIPlugin(csiPlugin: any) {
    this.addLine('csi_plugin {');
    this.indent();

    ['id', 'type', 'mount_dir', 'stage_publish_base_dir', 'health_timeout'].forEach(prop => {
      if (csiPlugin[prop] !== undefined) {
        this.generateProperty(prop, csiPlugin[prop]);
      }
    });

    if (csiPlugin.mount_options) {
      this.generateMountOptions(csiPlugin.mount_options);
    }

    this.dedent();
    this.addLine('}');
  }

  private generateConstraints(constraints: any[]) {
    constraints.forEach(constraint => {
      this.addLine('constraint {');
      this.indent();

      ['attribute', 'operator', 'value'].forEach(prop => {
        if (constraint[prop] !== undefined) {
          this.generateProperty(prop, constraint[prop]);
        }
      });

      this.dedent();
      this.addLine('}');
    });
  }

  private generateAffinities(affinities: any[]) {
    affinities.forEach(affinity => {
      this.addLine('affinity {');
      this.indent();

      ['attribute', 'operator', 'value', 'weight'].forEach(prop => {
        if (affinity[prop] !== undefined) {
          this.generateProperty(prop, affinity[prop]);
        }
      });

      this.dedent();
      this.addLine('}');
    });
  }

  private generateSpreads(spreads: any[]) {
    spreads.forEach(spread => {
      this.addLine('spread {');
      this.indent();

      ['attribute', 'weight'].forEach(prop => {
        if (spread[prop] !== undefined) {
          this.generateProperty(prop, spread[prop]);
        }
      });

      if (spread.target) {
        Object.entries(spread.target).forEach(([targetName, target]) => {
          this.addLine(`target "${targetName}" {`);
          this.indent();
          
          Object.entries(target as any).forEach(([key, value]) => {
            this.generateProperty(key, value);
          });

          this.dedent();
          this.addLine('}');
        });
      }

      this.dedent();
      this.addLine('}');
    });
  }

  private generateMeta(meta: Record<string, string>) {
    this.addLine('meta {');
    this.indent();

    Object.entries(meta).forEach(([key, value]) => {
      this.addLine(`${key} = ${this.formatValue(value)}`);
    });

    this.dedent();
    this.addLine('}');
  }

  private formatValue(value: any): string {
    if (typeof value === 'string') {
      return `"${value.replace(/"/g, '\\"')}"`;
    }
    
    if (typeof value === 'boolean') {
      return value.toString();
    }
    
    if (typeof value === 'number') {
      return value.toString();
    }
    
    if (Array.isArray(value)) {
      return `[${value.map(v => this.formatValue(v)).join(', ')}]`;
    }
    
    if (typeof value === 'object' && value !== null) {
      const entries = Object.entries(value).map(([k, v]) => `${k} = ${this.formatValue(v)}`);
      return `{\n${entries.join('\n')}\n}`;
    }
    
    return String(value);
  }

  private addLine(line = '') {
    if (line) {
      this.output.push(' '.repeat(this.indentLevel * this.options.indentSize) + line);
    } else {
      this.output.push('');
    }
  }

  private addComment(comment: string) {
    this.addLine(`# ${comment}`);
  }

  private indent() {
    this.indentLevel++;
  }

  private dedent() {
    this.indentLevel = Math.max(0, this.indentLevel - 1);
  }
}
